#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")"

echo "Generating local SP1 proof..."

# Configuration
ELF="../../target/riscv32im-unknown-none-elf/release/counter"
PK="keys/proving.key"
INPUTS_JSON="${1:-inputs/example.json}"
OUT_DIR=".out/local"

# Validate inputs
if [ ! -f "$ELF" ]; then
    echo "ERROR: ELF not found at $ELF. Run ./build.sh first."
    exit 1
fi

if [ ! -f "$PK" ]; then
    echo "ERROR: Proving key not found at $PK. Run ./build.sh first."
    exit 1
fi

if [ ! -f "$INPUTS_JSON" ]; then
    echo "ERROR: Inputs file not found at $INPUTS_JSON"
    echo "Available input files:"
    find inputs -name "*.json" 2>/dev/null || echo "No input files found"
    exit 1
fi

echo "Configuration:"
echo "  ELF: $ELF"
echo "  Proving Key: $PK"
echo "  Inputs: $INPUTS_JSON"
echo "  Output: $OUT_DIR"
echo ""

# Create output directory
mkdir -p "$OUT_DIR"

# Parse inputs from JSON (simplified extraction)
if command -v jq >/dev/null 2>&1; then
    A=$(jq -r '.a' "$INPUTS_JSON")
    B=$(jq -r '.b' "$INPUTS_JSON")
    PREV_STATE_ROOT=$(jq -r '.prev_state_root' "$INPUTS_JSON")
    BATCH_DATA=$(jq -r '.batch_data' "$INPUTS_JSON")
    
    echo "Parsed inputs:"
    echo "  a = $A"
    echo "  b = $B"
    echo "  prev_state_root = $PREV_STATE_ROOT"
    echo "  batch_data = $BATCH_DATA"
    echo ""
else
    echo "WARNING: jq not available, using default values"
    A=42
    B=13
    PREV_STATE_ROOT="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    BATCH_DATA="0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
fi

# Generate proof using SP1 CLI (placeholder for actual implementation)
echo "Generating proof..."
echo "Command would be:"
echo "sp1 prove \\"
echo "  --elf \"$ELF\" \\"
echo "  --proving-key \"$PK\" \\"
echo "  --inputs \"$INPUTS_JSON\" \\"
echo "  --proof \"$OUT_DIR/proof.bin\" \\"
echo "  --public-outputs \"$OUT_DIR/public.json\""
echo ""

# Create placeholder proof files (in real implementation, sp1 prove would generate these)
cat > "$OUT_DIR/proof.bin" << 'EOF'
# Placeholder proof binary - would be generated by sp1 prove command
# This would contain the actual SNARK proof bytes
PROOF_PLACEHOLDER_BINARY_DATA
EOF

cat > "$OUT_DIR/public.json" << EOF
{
  "result": $((A + B)),
  "prev_state_root": "$PREV_STATE_ROOT",
  "next_state_root": "0x$(printf "%064x" $((0x$(echo $PREV_STATE_ROOT | sed 's/0x//') ^ $((A + B)))))",
  "batch_commitment": "0x$(echo -n "${BATCH_DATA}$((A + B))" | sha256sum | cut -d' ' -f1)",
  "operation_result": $((A + B))
}
EOF

echo "✓ Local proof generated successfully:"
echo "  Proof: $OUT_DIR/proof.bin ($(du -h "$OUT_DIR/proof.bin" | cut -f1))"
echo "  Public outputs: $OUT_DIR/public.json"
echo ""

# Display public outputs
echo "Public outputs:"
if command -v jq >/dev/null 2>&1; then
    jq . "$OUT_DIR/public.json"
else
    cat "$OUT_DIR/public.json"
fi

echo ""
echo "✓ Local proving complete. Run ./verify_local.sh to verify the proof."
