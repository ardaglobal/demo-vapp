use crate::{
    config::Config,
    contracts::{ContractAddresses, IArithmetic, ISP1Verifier},
    error::{EthereumError, Result},
    types::*,
};
use alloy_primitives::{Bytes, FixedBytes, TxHash, U256};
use alloy_provider::{Provider, ProviderBuilder};
use alloy_rpc_types_eth::{BlockNumberOrTag, Filter, Log, TransactionReceipt};
use alloy_signer_local::PrivateKeySigner;
use std::sync::Arc;
use tokio::time::{interval, timeout, Duration};
use tracing::{debug, error, info, warn};

#[cfg(feature = "database")]
use crate::cache::EthereumCache;

pub struct EthereumClient {
    config: Config,
    http_provider: Arc<dyn Provider>,
    contracts: ContractAddresses,
    signer: Option<PrivateKeySigner>,

    #[cfg(feature = "database")]
    cache: Option<EthereumCache>,
}

impl EthereumClient {
    pub async fn new(config: Config) -> Result<Self> {
        config.validate()?;

        let http_provider = ProviderBuilder::new().on_http(config.network.rpc_url.clone());

        let contracts = ContractAddresses::new(
            config.contract.arithmetic_contract,
            config.contract.verifier_contract,
        );

        let signer = if let Some(signer_config) = &config.signer {
            Some(
                PrivateKeySigner::from_bytes(&FixedBytes::<32>::try_from(hex::decode(&signer_config.private_key)?.as_slice())?)
                    .map_err(|e| EthereumError::Signer(e.to_string()))?,
            )
        } else {
            None
        };

        Ok(Self {
            config,
            http_provider: Arc::new(http_provider),
            contracts,
            signer,

            #[cfg(feature = "database")]
            cache: None,
        })
    }

    #[cfg(feature = "database")]
    pub async fn with_cache(mut self, cache: EthereumCache) -> Result<Self> {
        self.cache = Some(cache);
        Ok(self)
    }

    pub async fn publish_state_root(
        &self,
        state_id: StateId,
        new_state_root: StateRoot,
        proof: Bytes,
        public_values: Bytes,
    ) -> Result<StateUpdate> {
        let signer = self.signer.as_ref().ok_or_else(|| {
            EthereumError::Config("Signer required for state updates".to_string())
        })?;

        // TODO: Implement proper contract call encoding
        let call_data = Bytes::new(); // Placeholder
        let tx_hash = self.send_transaction_with_retry(self.contracts.arithmetic, call_data, 3).await?;

        let receipt = self.wait_for_confirmation(tx_hash, 12).await?;

        let state_update = StateUpdate {
            state_id,
            new_state_root,
            proof,
            public_values,
            block_number: receipt.block_number,
            transaction_hash: Some(tx_hash),
        };

        #[cfg(feature = "database")]
        if let Some(cache) = &self.cache {
            cache.store_state_update(&state_update).await?;
        }

        info!(
            "State root published successfully. State ID: {:?}, Block: {:?}, TX: {:?}",
            state_id, receipt.block_number, tx_hash
        );

        Ok(state_update)
    }

    pub async fn batch_publish_state_roots(
        &self,
        updates: Vec<(StateId, StateRoot, Bytes, Bytes)>,
    ) -> Result<BatchStateUpdate> {
        let signer = self.signer.as_ref().ok_or_else(|| {
            EthereumError::Config("Signer required for state updates".to_string())
        })?;

        if updates.is_empty() {
            return Err(EthereumError::Config("No updates provided".to_string()));
        }

        let mut state_ids = Vec::new();
        let mut new_state_roots = Vec::new();
        let mut proofs = Vec::new();
        let mut results = Vec::new();
        
        for (state_id, new_state_root, proof, result) in updates {
            state_ids.push(state_id);
            new_state_roots.push(new_state_root);
            proofs.push(proof);
            results.push(result);
        }

        // TODO: Implement proper contract call encoding
        let call_data = Bytes::new(); // Placeholder
        let tx_hash = self.send_transaction_with_retry(self.contracts.arithmetic, call_data, 3).await?;

        let receipt = self.wait_for_confirmation(tx_hash, 12).await?;

        let success_flags = vec![true; state_ids.len()];

        let batch_update = BatchStateUpdate {
            state_ids,
            new_state_roots,
            proofs,
            results,
            transaction_hash: tx_hash,
            block_number: receipt.block_number.unwrap_or_default(),
            gas_used: U256::from(receipt.gas_used),
            success_flags,
        };

        info!(
            "Batch state roots published successfully. Count: {}, Block: {:?}, TX: {:?}",
            batch_update.state_ids.len(),
            batch_update.block_number,
            tx_hash
        );

        Ok(batch_update)
    }

    pub async fn verify_zk_proof(
        &self,
        proof: Bytes,
        public_values: Bytes,
    ) -> Result<ProofVerificationResult> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::verifyArithmeticProofCall {
            publicValues: public_values.clone(),
            proofBytes: proof.clone(),
        };

        let result = contract.call(&call).await.map_err(|e| {
            EthereumError::ProofVerificationFailed(format!("Proof verification failed: {}", e))
        })?;

        // TODO: Implement proper keccak256 hashing
        let proof_id = FixedBytes::ZERO; // Placeholder

        let current_block = self.http_provider.get_block_number().await?;

        let verification_result = ProofVerificationResult {
            proof_id,
            verified: true,
            result: Some(public_values),
            block_number: current_block,
            gas_used: U256::from(500_000), // Estimated
            error_message: None,
        };

        debug!("ZK proof verified successfully. Result: {}", result._0);

        Ok(verification_result)
    }

    pub async fn check_inclusion_proof(
        &self,
        leaf_hash: FixedBytes<32>,
        leaf_index: u64,
        siblings: Vec<FixedBytes<32>>,
        root: StateRoot,
    ) -> Result<InclusionProof> {
        let verified = self
            .verify_merkle_proof(leaf_hash, leaf_index, &siblings, root)
            .await?;

        Ok(InclusionProof {
            leaf_hash,
            leaf_index,
            siblings,
            root,
            verified,
        })
    }

    pub async fn get_current_state(&self, state_id: StateId) -> Result<StateResponse> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::getCurrentStateCall { stateId: state_id };
        let state_root = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get current state: {}", e)))?
            ._0;

        let current_block = self.http_provider.get_block_number().await?;
        let block = self
            .http_provider
            .get_block_by_number(BlockNumberOrTag::Number(current_block))
            .await?;
        let timestamp = block.map(|b| b.header.timestamp).unwrap_or_default();

        let latest_proof_call = IArithmetic::getLatestProofCall { stateId: state_id };
        let latest_proof = contract.call(&latest_proof_call).await.ok();
        let proof_id = latest_proof
            .map(|p| p.proofId)
            .filter(|id| *id != FixedBytes::ZERO);

        Ok(StateResponse {
            state_id,
            state_root,
            block_number: current_block,
            timestamp,
            proof_id,
        })
    }

    pub async fn get_historical_states(
        &self,
        state_id: StateId,
        limit: Option<u64>,
    ) -> Result<HistoricalState> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::readStateHistoryCall {
            stateId: state_id,
            limit: U256::from(limit.unwrap_or(0)),
        };

        let states = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get state history: {}", e)))?
            ._0;

        let proof_ids_call = IArithmetic::getProofsByStateIdCall { stateId: state_id };
        let proof_ids = contract
            .call(&proof_ids_call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof IDs: {}", e)))?
            ._0;

        let mut block_numbers = Vec::new();
        let mut timestamps = Vec::new();

        for proof_id in &proof_ids {
            let timestamp_call = IArithmetic::getProofTimestampCall { proofId: *proof_id };
            let timestamp = contract.call(&timestamp_call).await.unwrap_or_default()._0;
            timestamps.push(timestamp);

            block_numbers.push(0u64);
        }

        Ok(HistoricalState {
            state_id,
            state_roots: states,
            block_numbers,
            timestamps,
            proof_ids,
        })
    }

    pub async fn monitor_events(&self) -> Result<()> {
        if !self.config.monitoring.enable_event_monitoring {
            info!("Event monitoring is disabled");
            return Ok(());
        }

        info!(
            "Starting event monitoring for contract: {:?}",
            self.contracts.arithmetic
        );

        let mut interval = interval(Duration::from_secs(
            self.config.monitoring.polling_interval_seconds,
        ));
        let mut last_block = self.get_deployment_block().await?;

        loop {
            interval.tick().await;

            match self.process_events_batch(last_block).await {
                Ok(latest_block) => {
                    last_block = latest_block;
                }
                Err(e) => {
                    error!("Error processing events: {}", e);
                    tokio::time::sleep(Duration::from_secs(5)).await;
                }
            }
        }
    }

    pub async fn get_network_stats(&self) -> Result<NetworkStats> {
        let block_number = self.http_provider.get_block_number().await?;
        let gas_price = self.http_provider.get_gas_price().await?;

        let latest_block = self
            .http_provider
            .get_block_by_number(BlockNumberOrTag::Latest)
            .await?;

        let base_fee = latest_block
            .and_then(|block| block.header.base_fee_per_gas)
            .map(|fee| U256::from(fee));

        let chain_id = self.http_provider.get_chain_id().await?;
        let sync_status = self.check_sync_status().await.unwrap_or(false);

        Ok(NetworkStats {
            chain_id,
            block_number,
            gas_price: U256::from(gas_price),
            base_fee,
            network_name: self.config.network.name.clone(),
            sync_status,
        })
    }

    // ==========================================
    // INDEPENDENT VERIFICATION METHODS
    // ==========================================
    // These methods allow users to independently verify your vApp's behavior
    // by querying the smart contract directly without trusting your service.

    /// Get the verifier key from the arithmetic contract
    /// This is the SP1 program verification key that users can use for independent verification
    pub async fn get_verifier_key(&self) -> Result<FixedBytes<32>> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::arithmeticProgramVKeyCall {};
        let vkey = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get verifier key: {}", e)))?
            ._0;

        info!("Retrieved verifier key: {:?}", vkey);
        Ok(vkey)
    }

    /// Get the stored result (public values) for a specific proof ID
    /// Users can use this to verify what the proof claims to prove
    pub async fn get_proof_result(&self, proof_id: ProofId) -> Result<Bytes> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::getStoredResultCall { proofId: proof_id };
        let result = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof result: {}", e)))?
            ._0;

        if result.is_empty() {
            return Err(EthereumError::ProofVerificationFailed(format!(
                "No result found for proof ID: {:?}",
                proof_id
            )));
        }

        info!(
            "Retrieved proof result for {:?}: {} bytes",
            proof_id,
            result.len()
        );
        Ok(result)
    }

    /// Get the stored proof bytes for a specific proof ID
    /// Users can use this proof data for independent verification
    pub async fn get_proof_data(&self, proof_id: ProofId) -> Result<Bytes> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::getStoredProofCall { proofId: proof_id };
        let proof = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof data: {}", e)))?
            ._0;

        if proof.is_empty() {
            return Err(EthereumError::ProofVerificationFailed(format!(
                "No proof data found for proof ID: {:?}",
                proof_id
            )));
        }

        info!(
            "Retrieved proof data for {:?}: {} bytes",
            proof_id,
            proof.len()
        );
        Ok(proof)
    }

    /// Get the current state root for a specific state ID
    /// Users can verify that state transitions are correct
    pub async fn get_state_root(&self, state_id: StateId) -> Result<StateRoot> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::getCurrentStateCall { stateId: state_id };
        let state_root = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get state root: {}", e)))?
            ._0;

        if state_root == StateRoot::ZERO {
            return Err(EthereumError::StateNotFound(format!(
                "No state found for state ID: {:?}",
                state_id
            )));
        }

        info!("Retrieved state root for {:?}: {:?}", state_id, state_root);
        Ok(state_root)
    }

    /// Get comprehensive verification data for a proof ID
    /// Returns all data needed for independent verification in one call
    pub async fn get_verification_data(&self, proof_id: ProofId) -> Result<VerificationData> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        // Get proof details (proof, result, verified status)
        let details_call = IArithmetic::readProofDetailsCall { proofId: proof_id };
        let details = contract
            .call(&details_call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof details: {}", e)))?;

        if details.proof.is_empty() {
            return Err(EthereumError::ProofVerificationFailed(format!(
                "Proof not found: {:?}",
                proof_id
            )));
        }

        // Get verifier key
        let vkey_call = IArithmetic::arithmeticProgramVKeyCall {};
        let verifier_key = contract
            .call(&vkey_call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get verifier key: {}", e)))?
            ._0;

        // Get proof metadata
        let metadata_call = IArithmetic::getProofMetadataCall { proofId: proof_id };
        let metadata = contract
            .call(&metadata_call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof metadata: {}", e)))?
            ._0;

        // Get associated state root
        let state_root_call = IArithmetic::getCurrentStateCall {
            stateId: metadata.stateId,
        };
        let state_root = contract
            .call(&state_root_call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get state root: {}", e)))?
            ._0;

        let verification_data = VerificationData {
            proof_id,
            state_id: metadata.stateId,
            proof_bytes: details.proof,
            public_values: details.result,
            verifier_key,
            state_root,
            submitter: metadata.submitter,
            timestamp: metadata.timestamp.try_into().unwrap_or(0),
            verified_on_chain: details.verified,
            block_number: None, // Would need additional call to get this
        };

        info!(
            "Retrieved complete verification data for proof {:?}",
            proof_id
        );
        Ok(verification_data)
    }

    /// Get all proof IDs associated with a state ID
    /// Useful for auditing all proofs that contributed to a state
    pub async fn get_state_proof_history(&self, state_id: StateId) -> Result<Vec<ProofId>> {
        let contract = // TODO: Contract::new(self.contracts.arithmetic, self.http_provider.clone());

        let call = IArithmetic::getProofsByStateIdCall { stateId: state_id };
        let proof_ids = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get proof history: {}", e)))?
            ._0;

        info!(
            "Retrieved {} proof IDs for state {:?}",
            proof_ids.len(),
            state_id
        );
        Ok(proof_ids)
    }

    /// Verify a proof independently using on-chain data and the SP1 verifier
    /// This provides complete trustless verification
    pub async fn verify_proof_independently(
        &self,
        proof_id: ProofId,
    ) -> Result<IndependentVerificationResult> {
        info!("Starting independent verification for proof {:?}", proof_id);

        // Get all verification data
        let verification_data = self.get_verification_data(proof_id).await?;

        // Verify the proof using the verifier contract
        let verifier_contract = // TODO: Contract::new(self.contracts.verifier, self.http_provider.clone());

        let verify_call = ISP1Verifier::verifyProofCall {
            programVKey: verification_data.verifier_key,
            publicValues: verification_data.public_values.clone(),
            proofBytes: verification_data.proof_bytes.clone(),
        };

        let verification_result = match verifier_contract.call(&verify_call).await {
            Ok(_) => {
                info!(
                    "✓ Proof {:?} verified successfully by SP1 verifier",
                    proof_id
                );
                true
            }
            Err(e) => {
                warn!("✗ Proof {:?} failed SP1 verification: {}", proof_id, e);
                false
            }
        };

        // Additional consistency checks
        let consistency_checks = self.perform_consistency_checks(&verification_data).await?;

        let result = IndependentVerificationResult {
            proof_id,
            sp1_verification_passed: verification_result,
            on_chain_verification_status: verification_data.verified_on_chain,
            consistency_checks_passed: consistency_checks.all_passed,
            consistency_details: consistency_checks,
            verification_data,
            verified_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        info!("Independent verification completed for proof {:?}. SP1: {}, OnChain: {}, Consistency: {}",
            proof_id, result.sp1_verification_passed, result.on_chain_verification_status, result.consistency_checks_passed);

        Ok(result)
    }

    /// Get verifier contract version for compatibility checking
    pub async fn get_verifier_version(&self) -> Result<String> {
        let contract = // TODO: Contract::new(self.contracts.verifier, self.http_provider.clone());

        let call = ISP1Verifier::VERSIONCall {};
        let version = contract
            .call(&call)
            .await
            .map_err(|e| EthereumError::Contract(format!("Failed to get verifier version: {}", e)))?
            ._0;

        info!("Verifier version: {}", version);
        Ok(version)
    }

    /// Helper method to perform consistency checks on verification data
    async fn perform_consistency_checks(
        &self,
        data: &VerificationData,
    ) -> Result<ConsistencyChecks> {
        let mut checks = ConsistencyChecks::default();

        // Check 1: Verify proof ID matches hash of proof bytes
        let computed_proof_id = keccak256(data.proof_bytes.as_ref());
        checks.proof_id_matches_hash = computed_proof_id.as_slice() == data.proof_id.as_slice();

        // Check 2: Verify state exists and is non-zero
        checks.state_exists = data.state_root != StateRoot::ZERO;

        // Check 3: Verify proof and public values are non-empty
        checks.proof_data_present = !data.proof_bytes.is_empty() && !data.public_values.is_empty();

        // Check 4: Verify timestamp is reasonable (not in future, not too old)
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        checks.timestamp_reasonable =
            data.timestamp <= now && data.timestamp > (now - 365 * 24 * 3600); // Within last year

        // Check 5: Verify verifier key is not zero
        checks.verifier_key_valid = data.verifier_key != FixedBytes::ZERO;

        checks.all_passed = checks.proof_id_matches_hash
            && checks.state_exists
            && checks.proof_data_present
            && checks.timestamp_reasonable
            && checks.verifier_key_valid;

        Ok(checks)
    }

    async fn send_transaction_with_retry(
        &self,
        to_address: alloy_primitives::Address,
        call_data: Bytes,
        max_retries: u32,
    ) -> Result<TxHash> {
        for attempt in 0..max_retries {
            match self.send_transaction(to_address, call_data.clone()).await {
                Ok(tx_hash) => return Ok(tx_hash),
                Err(e) => {
                    if attempt == max_retries - 1 {
                        return Err(e);
                    }
                    warn!(
                        "Transaction attempt {} failed: {}. Retrying...",
                        attempt + 1,
                        e
                    );
                    tokio::time::sleep(Duration::from_secs(2_u64.pow(attempt))).await;
                }
            }
        }
        unreachable!()
    }

    async fn send_transaction(&self, _to_address: alloy_primitives::Address, _call_data: Bytes) -> Result<TxHash> {
        // This is a simplified implementation
        // In reality, you'd need to handle gas estimation, nonce management, etc.
        todo!("Implement transaction sending with proper gas estimation and signing")
    }

    async fn wait_for_confirmation(&self, tx_hash: TxHash, confirmations: u64) -> Result<Receipt> {
        let timeout_duration = Duration::from_secs(self.config.monitoring.timeout_seconds);

        timeout(timeout_duration, async {
            loop {
                if let Some(receipt) = self.http_provider.get_transaction_receipt(tx_hash).await? {
                    let current_block = self.http_provider.get_block_number().await?;
                    let tx_block = receipt.block_number.unwrap_or_default();

                    if current_block >= tx_block + confirmations {
                        return Ok(receipt);
                    }
                }

                tokio::time::sleep(Duration::from_secs(2)).await;
            }
        })
        .await
        .map_err(|_| EthereumError::Timeout("Transaction confirmation timeout".to_string()))?
    }

    async fn process_events_batch(&self, from_block: u64) -> Result<u64> {
        let current_block = self.http_provider.get_block_number().await?;
        let to_block = std::cmp::min(
            from_block + self.config.monitoring.max_block_range,
            current_block,
        );

        if from_block >= to_block {
            return Ok(from_block);
        }

        let filter = Filter::new()
            .address(self.contracts.arithmetic)
            .from_block(from_block)
            .to_block(to_block);

        let logs = self.http_provider.get_logs(&filter).await?;

        for log in logs {
            if let Err(e) = self.process_event_log(log).await {
                error!("Failed to process event log: {}", e);
            }
        }

        info!("Processed events from block {} to {}", from_block, to_block);
        Ok(to_block + 1)
    }

    async fn process_event_log(&self, log: Log) -> Result<()> {
        // Process different event types based on the log topics
        // This is a simplified implementation
        debug!("Processing event log: {:?}", log);

        #[cfg(feature = "database")]
        if let Some(cache) = &self.cache {
            let event = ContractEvent {
                event_type: "unknown".to_string(),
                state_id: None,
                proof_id: None,
                block_number: log.block_number.unwrap_or_default(),
                transaction_hash: log.transaction_hash.unwrap_or_default().into(),
                log_index: log.log_index.unwrap_or_default(),
                timestamp: 0, // Would need to fetch block timestamp
            };
            cache.store_event(&event).await?;
        }

        Ok(())
    }

    async fn get_deployment_block(&self) -> Result<u64> {
        if let Some(block) = self.config.contract.deployment_block {
            Ok(block)
        } else {
            let current_block = self.http_provider.get_block_number().await?;
            Ok(current_block.saturating_sub(10000))
        }
    }

    async fn check_sync_status(&self) -> Result<bool> {
        match self.http_provider.get_block_number().await {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }

    async fn verify_merkle_proof(
        &self,
        leaf_hash: FixedBytes<32>,
        leaf_index: u64,
        siblings: &[FixedBytes<32>],
        root: StateRoot,
    ) -> Result<bool> {
        // Implement Merkle proof verification logic
        // This is a placeholder implementation
        let mut computed_hash = leaf_hash;
        let mut index = leaf_index;

        for sibling in siblings {
            if index % 2 == 0 {
                computed_hash =
                    keccak256(&[computed_hash.as_slice(), sibling.as_slice()].concat()).into();
            } else {
                computed_hash =
                    keccak256(&[sibling.as_slice(), computed_hash.as_slice()].concat()).into();
            }
            index /= 2;
        }

        Ok(computed_hash == root)
    }
}

// Helper function for keccak256 hashing
fn keccak256(input: &[u8]) -> [u8; 32] {
    use alloy_primitives::keccak256;
    keccak256(input).into()
}

// Helper trait for unzipping 4-tuples
trait Unzip4<A, B, C, D> {
    fn unzip4(self) -> (Vec<A>, Vec<B>, Vec<C>, Vec<D>);
}

impl<A, B, C, D> Unzip4<A, B, C, D> for Vec<(A, B, C, D)> {
    fn unzip4(self) -> (Vec<A>, Vec<B>, Vec<C>, Vec<D>) {
        let mut a = Vec::with_capacity(self.len());
        let mut b = Vec::with_capacity(self.len());
        let mut c = Vec::with_capacity(self.len());
        let mut d = Vec::with_capacity(self.len());

        for (val_a, val_b, val_c, val_d) in self {
            a.push(val_a);
            b.push(val_b);
            c.push(val_c);
            d.push(val_d);
        }

        (a, b, c, d)
    }
}

pub type Receipt = TransactionReceipt;
